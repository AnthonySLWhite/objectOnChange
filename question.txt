I've been trying to build a constructor that uses JS proxy to watch objects and arrays for changes and executes a function in case you change them.
This is what I have so far:

    const isFunction = function(obj) {
      return !!(obj && obj.constructor && obj.call && obj.apply);
    };
    const _watch = (activator, isConst) => {
      if (isFunction(activator)) {
        const proxy = new Proxy({}, {
          set: (obj, prop, value) => {
            if (isConst) {
              if (prop in obj /*?*/) {
                console.error('Property already exists: ', prop);
                if (isConst === 1) {
                  return 1;
                }
                return 0;
              }
              obj[prop] = value;
              activator();
              return 1;
            }
            obj[prop] = value; /*?*/
            activator();
            return 1;
          }
        });
        proxy.SetState = function(object) {
          Object.keys(object).map(obj => (proxy[obj] = object[obj]));
        };
        return proxy;
      }
      console.error('The watcher did not get any function!');
      return 0;
    };

To sum it up, it exports the function "_watch" that takes in a function that is activated when an object or array changes. It also takes a value that can be 0, 1 or 3.

0 - All values can be changed

1 - Values are constants and gives a warning if you try to change them

2 - Values are constantes and throws error if you try to change them

There is also a SetState method that is created to help add more properties like in React.JS.

**My problem is:** how can I change the object returned like an array and keep the methods like proxy.push, .pop, ...

Opinion on the code so far is apreciated as well :)
Do you think this is the way to go? Any changes you would suggest?
